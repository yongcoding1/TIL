제네릭
=
* 제네릭 클래스와 인터페이스
```java
접근 지정자 class 클래스명<T> // 제네릭 타입 변수명이 1개일 때, 타입 T를 사용한 코드
접근 지정자 class 클래스명<K, V> // 제네릭 타입 변수명이 2개일 때, 타입 K, V를 사용한 코드
접근 지정자 interface 클래스명<T> // 제네릭 타입 변수명이 1개일 때, 타입 T를 사용한 코드
접근 지정자 interface 클래스명<K, V> // 제네릭 타입 변수명이 2개일 때, 타입 K, V를 사용한 코드
```
* 제네릭 클래스의 객체 생성
```java
클래스명<실제 제네릭 타입> 참조 변수명 = new 클래스명<실제 제네릭 타입>();
or
클래스명<실제 제네릭 타입> 참조 변수명 = new 클래스명<>(); 
// 제네릭 클래스는 클래스를 정의하는 시점이 아닌 객체를 생성하는 시점에 타입을 지정한다.
```
> 예시
```java
Class1<String> c1 = new Class1<String>();
Class1<String> c1 = new Class1<>();
```
* 제네릭 메서드
```java
접근 지정자 <T> T 메서드명 (T t) // 제네릭 타입 변수명이 1개일 때, 타입 T를 사용한 코드
접근 지정자 <T, V> T 메서드명 (T t, V v) // 제네릭 타입 변수명이 2개일 때, 타입 T, V를 사용한 코드
접근 지정자 <T> void 메서드명 (T t) // 매개변수에만 제네릭이 사용됐을 때, 타입 T를 사용한 코드
접근 지정자 <T> T 메서드명 (int a) // 리턴 타입에만 제네릭이 사용됐을 때, 타입 T를 사용한 코드
```
* 제네릭 메서드 호출
```java
참조 객체.<실제 제네릭 타입>메서드명(입력매개변수);
// 제네릭 메서드는 호출되는 시점에 실제 제네릭 타입을 지정한다.
```
> 예시
```java
String str1 = gm.<String>method1("안녕");
String str1 = gm.method1("안녕"); // 입력매개변수를 보고 제네릭 타입 변수의 실제 타입이 예측가능하면 생략 가능
```
* 제네릭 타입 범위 제한
>1. 제네릭 클래스의 타입 제한
```java
접근 지정자 class 클래스명 <T extends 최상위 클래스/인터페이스명>
// 여기서의 extends는 상속의 의미가 아니고 최상위 클래스/인터페이스로 지정한다는 의미이다. 
// 따라서 상속과 달리, 클래스이든, 인터페이스이든 항상 extends 키워드를 사용한다.
```
>2. 제네릭 메서드의 타입 제한
```java
접근 지정자 <T extends 최상위 클래스/인터페이스명> T 메서드명(T t)
```
>3. 메서드 매개변수일 때 제네릭 클래스의 타입 제한
```java
리턴 타입 메서드명(제네릭 클래스명<제네릭 타입명> 참조 변수명) // 지정 타입인 객체만 가능
리턴 타입 메서드명(제네릭 클래스명<?> 참조 변수명) // 모든 타입인 객체 가능
리턴 타입 메서드명(제네릭 클래스명<? extends 상위 클래스/인터페이스> 참조 변수명) // 상위 클래스 또는 상위 클래스의 자식 클래스인 객체만 가능
리턴 타입 메서드명(제네릭 클래스명<? super 하위 클래스/인터페이스> 참조 변수명) // 하위 클래스 또는 하위 클래스의 부모 클래스인 객체만 가능
```
* 제네릭의 상속
 
부모 클래스와 제네릭 타입 변수의 개수가 동일할 때
```java
class Parent<K, V> {
}
class Child<K, V> extends Parent<K, V> {
}
```
부모 클래스보다 제네릭 타입 변수의 개수가 많을 때
```java
class Parent<K> {
}
class Child<K, V> extends Parent<K> {
}
```
